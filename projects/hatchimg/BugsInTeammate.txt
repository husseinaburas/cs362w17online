The first bug that I found in Elton's code was in my unit test for updateCoins(). I tested to see if a call to the function would fail with bad input – specifically, negative numbers for the player and bonus parameters – but the function still returned with a value of zero (i.e. success). The cause was by no fault of Elton's; as far as I could tell by comparing it to the original version found in dominion.c, he made no changes to the function. The bug was a result of its initial implementation, which did not have a handler for attempting to access an invalid index in the handCount array; rather, it would just produce a null value for something nonexistent and skip the function's for loop. As for the bonus, the function did not run any sort of check for impossible (negative) values being provided for the bonus. Instead, it simply performed its arithmetic operation with whatever int was representing bonus and ultimately returned 0.

The next two bugs I found were in my unit test of scoreFor(). Again, this was by no fault of Elton's, as they were caused by problems in the original code. I documented these same bugs (and their cause) back in Assignment 3, where I said (some edits made):

There were two bugs uncovered by the unit test for scoreFor, both of which seem to be caused by the same error in the code. The first bug was that a standard (otherwise successful in that in completed and returned 0) call with normal input did not return the correct score. The second bug was that a call that was made when the player's score was negative (i.e. all of their cards were curse cards) did not return the correct score either. Upon closer inspection of the source code, the reason these bugs occur is because the scoreFor() function only loops through the deck the number of times equal to the size of the discard count. In other words, the number of times the loop goes through the deck should be equal to the size of the deck, not the size of the discard pile. By using the wrong number, that loop within scoreFor() will always produce the same number of points (and add them to the total) as the loop that tallies the points from the discard pile. This is error was the cause of both bugs, since they both involved the tally of points.

I uncovered two more bugs in my first card unit test, which was for smithy: the smithy card was not successfully added to the played card pile and the function returned successfully with a nonexistent handPos argument. The first bug was caused by the fact that Elton appears to have refactored the function to set the trash flag parameter when calling the discardCard function on the smithy card after it has been played. As such, it's not added to the played pile, but trashed instead. The second bug was, like the aforementioned bug caused by bad input, simply a result of not running a check on the handPos argument to make sure that it was a valid value; the function should always check to make sure that it's a positive (or zero) number since it will be used as in index.

There were two more bugs in my third card unit tests, which was for adventurer: after the function call, the player did not receive exactly two treasure cards, and the their hand did not increase by exactly two. These bugs were caused by a single fault that Elton introduced in his refactoring of the adventurer function, which was changing the condition of the loop to running while drawnTreasure is less than OR EQUAL TO 2, rather than just less than 2. As a result, the while loop would keep running until three treasure cards were drawn (i.e. greater than 2) instead of just two treasure cards. This caused not only the wrong number of treasure cards to end up in the player's hand, but also the wrong TOTAL number of cards in the player's hand after the call since three cards were added instead of two.

Finally, there was one bug found by my fourth card test, which was for outpost. Like some of the aforementioned functions, this function (technically a switch case in the cardEffect() function, since Elton did not refactor outpost) returned successfully with bad input in the form of a nonexistent handPos argument. And like before, the problem was because the function did not run any sort of check to see if the argument passed for the handPos parameter was zero or positive – which it should be since it would be used as an index in the player's hand array – or have any sort of error handler in the event that it tried to search in the player's hand array using a negative index.

All of my other tests (unit test 1 [shuffle], unit test 2 [buyCard], card test 2 [great hall], random adventurer test, random card test 1 [great hall], and random card test 2 [outpost]) passed successfully.