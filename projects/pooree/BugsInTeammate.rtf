{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\ftech\fcharset77 Symbol;\f2\fmodern\fcharset0 CourierNewPSMT;
}
{\colortbl;\red255\green255\blue255;\red45\green59\blue69;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww14900\viewh11000\viewkind0
\deftab720
\pard\pardeftab720\ri720\qc

\f0\i\b\fs28 \cf2 Bugs in Teammate Code\
\pard\pardeftab720\li720\fi-360\ri720
\ls1\ilvl0
\f1\i0\b0\fs22 \cf2 \'a5	
\f0 While examining branch coverage for random tests, I noticed an else branch was never being executed for the adventurer card function. After examination, I saw that cardDrawn = copper was being used to evaluate what should be a boolean statement rather than cardDrawn == copper and as such it was forcing the statement to always be evaluated as true and thus never executing the else branch (which should have been executed more often than the if!).\
\ls1\ilvl0
\f1 \'a5	
\f0 Throughout initial testing on my end, I had a hard time tracking what the proper number of cards should be in a player\'92s hand after the card has been played due to possible bugs in the discardCard function and/or the fact that some cards never have the discardCard function called. While examining the playSmithy function, I had the usual tests failing due to too many cards in the player\'92s hand after playing, but what had me more curious about the situation was in initially seen in the unit test- I saw that the deck count was one less card than expected. Upon discovering this, I turned on \'91NOISEY\'92 testing for the random tester for this card so I could see not only what tests were failing, but also, what the actual data for the failed test was. Between these two methods of examination, I was able to determine that when a player plays a Smithy card, rather than gaining 3 cards as they are supposed to, they are getting 4. The bug comes from this statement which executes 4 times, not 3:\
\pard\pardeftab720\li1440\fi-360\ri720
\ls1\ilvl1
\f2 \cf2 o	
\f0 for (i = 0; i <= 3; i++)\
\pard\pardeftab720\li720\fi-360\ri720
\ls1\ilvl1
\f1 \cf2 \'a5	
\f0 As described in the refactoring section, I didn\'92t find a bug in playVillage per say, but found an integration test error. My test suit initially tested Village from the cardEffect function. With that being the case, I saw a strange bug in Village that the supply counts were being changed even though it shouldn\'92t be. I ended up refactoring the test to just call the playVillage function (as the original intent was likely the case)- at that point the unit test bug was gone. Upon further inspection it appears the bug I found was an integration testing error. Even though the playVillage function returned 0, it was necessary to return 0 to exit out of the switch statement in cardEffect. Once that line was added, the functionality of the card was restored when the test was ran from cardEffect in addition to the true unit test where just the playVillage function was under test. \
\ls1\ilvl1
\f1 \'a5	
\f0 The same behavior from not returning 0 in the cardEffect function for refactored functions applied for adventurer as well. When looking at the source code, the same problem would apply when testing smithy from the cardEffect function, but that is the function I was truly unit testing and only tested from the playSmithy() test. This brings to light the importance of all levels of testing (unit, integration, etc)!\
}