Bugs in Teammate CodeBug: playAdventurer(): Drawn Treasure Updated IncorrectlyWhile examining branch coverage for random tests, I noticed an else branch was never being executed for the adventurer card function. After examination, I saw that cardDrawn = copper was being used to evaluate what should be a boolean statement rather than cardDrawn == copper and as such it was forcing the statement to always be evaluated as true and thus never executing the else branch (which should have been executed more often than the if!).Estimated severity of the bug:Though this bug will not cause the software to crash, it will have implications for the outcome of game play as it explicitly changes how the adventurer card plays.Priority of the bug:This is a moderately high priority bug. The bug does not cause the program to crash and I’d argue I’ve seen bugs of higher importance throughout testing this software in this course, but this bug will have an effect on game play and should be treated seriously as such. Bug: playSmithy(): Incorrect number of cards drawn by current playerThroughout initial testing on my end, I had a hard time tracking what the proper number of cards should be in a player’s hand after the card has been played due to possible bugs in the discardCard function and/or the fact that some cards never have the discardCard function called. While examining the playSmithy function, I had the usual tests failing due to too many cards in the player’s hand after playing, but what had me more curious about the situation was in initially seen in the unit test- I saw that the deck count was one less card than expected. Upon discovering this, I turned on ‘NOISEY’ testing for the random tester for this card so I could see not only what tests were failing, but also, what the actual data for the failed test was. Between these two methods of examination, I was able to determine that when a player plays a Smithy card, rather than gaining 3 cards as they are supposed to, they are getting 4. The bug comes from this statement which executes 4 times, not 3:o	for (i = 0; i <= 3; i++)Estimated severity of the bug:Though this bug will not cause the software to crash, it will have implications for the outcome of game play as it explicitly changes how the smithy card plays.Priority of the bug:This is a moderately high priority bug. The bug does not cause the program to crash and I’d argue I’ve seen bugs of higher importance throughout testing this software in this course, but this bug will have an effect on game play and should be treated seriously as such. Bugs in cardEffect causing integration testing errors:As described in the refactoring section, I didn’t find a bug in playVillage per say, but found an integration test error. My test suit initially tested Village from the cardEffect function. With that being the case, I saw a strange bug in Village that the supply counts were being changed even though it shouldn’t be. I ended up refactoring the test to just call the playVillage function (as the original intent was likely the case)- at that point the unit test bug was gone. Upon further inspection it appears the bug I found was an integration testing error. Even though the playVillage function returned 0, it was necessary to return 0 to exit out of the switch statement in cardEffect. Once that line was added, the functionality of the card was restored when the test was ran from cardEffect in addition to the true unit test where just the playVillage function was under test. The same behavior from not returning 0 in the cardEffect function for refactored functions applied for adventurer as well. When looking at the source code, the same problem would apply when testing smithy from the cardEffect function, but that is the function I was truly unit testing and only tested from the playSmithy() test. This brings to light the importance of all levels of testing (unit, integration, etc)!