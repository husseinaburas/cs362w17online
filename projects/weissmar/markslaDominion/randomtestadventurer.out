randomtestadventurer.c:

Testing playAdventurer()

Number of players = 4
kingdomCards[0] = 12
kingdomCards[1] = 14
kingdomCards[2] = 12
kingdomCards[3] = 8
kingdomCards[4] = 15
kingdomCards[5] = 23
kingdomCards[6] = 20
kingdomCards[7] = 13
kingdomCards[8] = 10
kingdomCards[9] = 22
********************************
TEST 1:
Active player = 1
Deck size =  8
Discard size =  4
Deck treasure count =  3
Discard treasure count =  0
TEST 1.11 FAILED
TEST 1.41 FAILED
********************************
TEST 2:
Active player = 1
Deck size =  8
Discard size =  9
Deck treasure count =  0
Discard treasure count =  4
TEST 2.11 FAILED
TEST 2.41 FAILED
********************************
TEST 3:
Active player = 0
Deck size =  9
Discard size =  6
Deck treasure count =  1
Discard treasure count =  1
TEST 3.21 FAILED
********************************
TEST 4:
Active player = 3
Deck size =  0
Discard size =  9
Deck treasure count =  0
Discard treasure count =  6
TEST 4.11 FAILED
TEST 4.41 FAILED
********************************
TEST 5:
Active player = 3
Deck size =  8
Discard size =  1
Deck treasure count =  0
Discard treasure count =  0
TEST 5.11 FAILED
********************************
TEST 6:
Active player = 1
Deck size =  10
Discard size =  9
Deck treasure count =  0
Discard treasure count =  1
TEST 6.21 FAILED
TEST 6.41 FAILED
********************************
TEST 7:
Active player = 2
Deck size =  7
Discard size =  7
Deck treasure count =  1
Discard treasure count =  2
TEST 7.11 FAILED
TEST 7.41 FAILED
********************************
TEST 8:
Active player = 3
Deck size =  7
Discard size =  4
Deck treasure count =  0
Discard treasure count =  3
TEST 8.11 FAILED
TEST 8.41 FAILED
********************************
TEST 9:
Active player = 3
Deck size =  1
Discard size =  0
Deck treasure count =  0
Discard treasure count =  0
TEST 9.11 FAILED
********************************
TEST 10:
Active player = 2
Deck size =  1
Discard size =  1
Deck treasure count =  0
Discard treasure count =  0
TEST 10.11 FAILED
********************************
TEST 11:
Active player = 0
Deck size =  4
Discard size =  7
Deck treasure count =  0
Discard treasure count =  0
TEST 11.11 FAILED
TEST 11.21 FAILED
TEST 11.41 FAILED
********************************
TEST 12:
Active player = 0
Deck size =  5
Discard size =  5
Deck treasure count =  0
Discard treasure count =  2
TEST 12.21 FAILED
********************************
TEST 13:
Active player = 2
Deck size =  1
Discard size =  9
Deck treasure count =  0
Discard treasure count =  0
TEST 13.11 FAILED
********************************
TEST 14:
Active player = 0
Deck size =  0
Discard size =  10
Deck treasure count =  0
Discard treasure count =  1
TEST 14.21 FAILED
********************************
TEST 15:
Active player = 1
Deck size =  5
Discard size =  10
Deck treasure count =  1
Discard treasure count =  1
TEST 15.11 FAILED
TEST 15.21 FAILED
TEST 15.41 FAILED
********************************
TEST 16:
Active player = 3
Deck size =  0
Discard size =  0
Deck treasure count =  0
Discard treasure count =  0
TEST 16.11 FAILED
********************************
TEST 17:
Active player = 1
Deck size =  0
Discard size =  3
Deck treasure count =  0
Discard treasure count =  0
TEST 17.11 FAILED
********************************
TEST 18:
Active player = 0
Deck size =  3
Discard size =  8
Deck treasure count =  0
Discard treasure count =  2
TEST 18.21 FAILED
********************************
TEST 19:
Active player = 3
Deck size =  5
Discard size =  0
Deck treasure count =  1
Discard treasure count =  0
TEST 19.21 FAILED
TEST 19.41 FAILED
********************************
TEST 20:
Active player = 1
Deck size =  9
Discard size =  2
Deck treasure count =  2
Discard treasure count =  0
TEST 20.11 FAILED
TEST 20.21 FAILED
TEST 20.41 FAILED
********************************
TEST 21:
Active player = 0
Deck size =  8
Discard size =  6
Deck treasure count =  0
Discard treasure count =  1
TEST 21.21 FAILED
********************************
TEST 22:
Active player = 0
Deck size =  5
Discard size =  2
Deck treasure count =  0
Discard treasure count =  0
TEST 22.11 FAILED
TEST 22.41 FAILED
********************************
TEST 23:
Active player = 0
Deck size =  2
Discard size =  5
Deck treasure count =  0
Discard treasure count =  1
TEST 23.21 FAILED
********************************
TEST 24:
Active player = 3
Deck size =  4
Discard size =  4
Deck treasure count =  1
Discard treasure count =  0
TEST 24.21 FAILED
TEST 24.41 FAILED
********************************
TEST 25:
Active player = 2
Deck size =  7
Discard size =  5
Deck treasure count =  3
Discard treasure count =  2
TEST 25.11 FAILED
TEST 25.41 FAILED
********************************
TEST 26:
Active player = 1
Deck size =  4
Discard size =  7
Deck treasure count =  1
Discard treasure count =  1
TEST 26.11 FAILED
TEST 26.21 FAILED
TEST 26.41 FAILED
********************************
TEST 27:
Active player = 1
Deck size =  7
Discard size =  6
Deck treasure count =  0
Discard treasure count =  1
TEST 27.21 FAILED
TEST 27.41 FAILED
********************************
TEST 28:
Active player = 0
Deck size =  3
Discard size =  2
Deck treasure count =  3
Discard treasure count =  0
TEST 28.11 FAILED
TEST 28.41 FAILED
********************************
TEST 29:
Active player = 3
Deck size =  7
Discard size =  9
Deck treasure count =  2
Discard treasure count =  2
TEST 29.11 FAILED
TEST 29.41 FAILED
********************************
TEST 30:
Active player = 1
Deck size =  10
Discard size =  8
Deck treasure count =  2
Discard treasure count =  2
TEST 30.11 FAILED
TEST 30.41 FAILED
********************************
TEST 31:
Active player = 0
Deck size =  8
Discard size =  5
Deck treasure count =  0
Discard treasure count =  2
TEST 31.21 FAILED
********************************
TEST 32:
Active player = 2
Deck size =  0
Discard size =  2
Deck treasure count =  0
Discard treasure count =  1
TEST 32.21 FAILED
TEST 32.41 FAILED
********************************
TEST 33:
Active player = 0
Deck size =  9
Discard size =  0
Deck treasure count =  2
Discard treasure count =  0
TEST 33.21 FAILED
********************************
TEST 34:
Active player = 3
Deck size =  5
Discard size =  1
Deck treasure count =  1
Discard treasure count =  0
TEST 34.21 FAILED
TEST 34.41 FAILED
********************************
TEST 35:
Active player = 3
Deck size =  6
Discard size =  8
Deck treasure count =  0
Discard treasure count =  2
TEST 35.11 FAILED
TEST 35.21 FAILED
TEST 35.41 FAILED
********************************
TEST 36:
Active player = 3
Deck size =  7
Discard size =  0
Deck treasure count =  2
Discard treasure count =  0
TEST 36.11 FAILED
TEST 36.21 FAILED
TEST 36.41 FAILED
********************************
TEST 37:
Active player = 1
Deck size =  7
Discard size =  9
Deck treasure count =  3
Discard treasure count =  3
TEST 37.11 FAILED
TEST 37.41 FAILED
********************************
TEST 38:
Active player = 2
Deck size =  9
Discard size =  2
Deck treasure count =  1
Discard treasure count =  0
TEST 38.21 FAILED
TEST 38.41 FAILED
********************************
TEST 39:
Active player = 3
Deck size =  0
Discard size =  1
Deck treasure count =  0
Discard treasure count =  0
TEST 39.11 FAILED
********************************
TEST 40:
Active player = 3
Deck size =  7
Discard size =  9
Deck treasure count =  0
Discard treasure count =  2
TEST 40.11 FAILED
TEST 40.21 FAILED
TEST 40.41 FAILED
********************************
TEST 41:
Active player = 3
Deck size =  10
Discard size =  0
Deck treasure count =  3
Discard treasure count =  0
TEST 41.11 FAILED
TEST 41.41 FAILED
********************************
TEST 42:
Active player = 2
Deck size =  7
Discard size =  8
Deck treasure count =  2
Discard treasure count =  1
TEST 42.11 FAILED
TEST 42.41 FAILED
********************************
TEST 43:
Active player = 0
Deck size =  9
Discard size =  0
Deck treasure count =  2
Discard treasure count =  0
TEST 43.21 FAILED
********************************
TEST 44:
Active player = 1
Deck size =  0
Discard size =  3
Deck treasure count =  0
Discard treasure count =  1
TEST 44.21 FAILED
TEST 44.41 FAILED
********************************
TEST 45:
Active player = 1
Deck size =  0
Discard size =  5
Deck treasure count =  0
Discard treasure count =  0
TEST 45.11 FAILED
********************************
TEST 46:
Active player = 3
Deck size =  3
Discard size =  10
Deck treasure count =  0
Discard treasure count =  4
TEST 46.11 FAILED
TEST 46.41 FAILED
********************************
TEST 47:
Active player = 2
Deck size =  7
Discard size =  5
Deck treasure count =  3
Discard treasure count =  1
TEST 47.11 FAILED
TEST 47.41 FAILED
********************************
TEST 48:
Active player = 3
Deck size =  3
Discard size =  6
Deck treasure count =  0
Discard treasure count =  1
TEST 48.21 FAILED
TEST 48.41 FAILED
********************************
TEST 49:
Active player = 3
Deck size =  8
Discard size =  9
Deck treasure count =  1
Discard treasure count =  1
TEST 49.11 FAILED
TEST 49.21 FAILED
TEST 49.41 FAILED
********************************
TEST 50:
Active player = 1
Deck size =  7
Discard size =  4
Deck treasure count =  1
Discard treasure count =  0
TEST 50.21 FAILED
TEST 50.41 FAILED
********************************
TEST 51:
Active player = 0
Deck size =  4
Discard size =  1
Deck treasure count =  0
Discard treasure count =  0
TEST 51.11 FAILED
TEST 51.41 FAILED
********************************
TEST 52:
Active player = 2
Deck size =  8
Discard size =  4
Deck treasure count =  0
Discard treasure count =  1
TEST 52.21 FAILED
TEST 52.41 FAILED
********************************
TEST 53:
Active player = 0
Deck size =  8
Discard size =  0
Deck treasure count =  2
Discard treasure count =  0
TEST 53.21 FAILED
********************************
TEST 54:
Active player = 3
Deck size =  9
Discard size =  1
Deck treasure count =  2
Discard treasure count =  0
TEST 54.11 FAILED
TEST 54.21 FAILED
TEST 54.41 FAILED
********************************
TEST 55:
Active player = 0
Deck size =  9
Discard size =  10
Deck treasure count =  2
Discard treasure count =  1
TEST 55.11 FAILED
TEST 55.41 FAILED
********************************
TEST 56:
Active player = 0
Deck size =  9
Discard size =  4
Deck treasure count =  4
Discard treasure count =  1
TEST 56.11 FAILED
TEST 56.41 FAILED
********************************
TEST 57:
Active player = 3
Deck size =  6
Discard size =  5
Deck treasure count =  1
Discard treasure count =  1
TEST 57.11 FAILED
TEST 57.21 FAILED
TEST 57.41 FAILED
********************************
TEST 58:
Active player = 0
Deck size =  10
Discard size =  7
Deck treasure count =  1
Discard treasure count =  0
TEST 58.21 FAILED
********************************
TEST 59:
Active player = 0
Deck size =  9
Discard size =  1
Deck treasure count =  3
Discard treasure count =  0
TEST 59.11 FAILED
TEST 59.41 FAILED
********************************
TEST 60:
Active player = 3
Deck size =  3
Discard size =  7
Deck treasure count =  0
Discard treasure count =  0
TEST 60.11 FAILED
********************************
TEST 61:
Active player = 3
Deck size =  9
Discard size =  2
Deck treasure count =  1
Discard treasure count =  0
TEST 61.21 FAILED
TEST 61.41 FAILED
********************************
TEST 62:
Active player = 1
Deck size =  1
Discard size =  1
Deck treasure count =  0
Discard treasure count =  0
TEST 62.11 FAILED
********************************
TEST 63:
Active player = 2
Deck size =  0
Discard size =  8
Deck treasure count =  0
Discard treasure count =  3
TEST 63.11 FAILED
TEST 63.41 FAILED
********************************
TEST 64:
Active player = 2
Deck size =  2
Discard size =  10
Deck treasure count =  0
Discard treasure count =  2
TEST 64.11 FAILED
TEST 64.21 FAILED
TEST 64.41 FAILED
********************************
TEST 65:
Active player = 0
Deck size =  2
Discard size =  2
Deck treasure count =  0
Discard treasure count =  1
TEST 65.21 FAILED
********************************
TEST 66:
Active player = 0
Deck size =  0
Discard size =  9
Deck treasure count =  0
Discard treasure count =  3
TEST 66.11 FAILED
TEST 66.41 FAILED
********************************
TEST 67:
Active player = 0
Deck size =  8
Discard size =  2
Deck treasure count =  1
Discard treasure count =  0
TEST 67.21 FAILED
********************************
TEST 68:
Active player = 0
Deck size =  10
Discard size =  0
Deck treasure count =  3
Discard treasure count =  0
TEST 68.11 FAILED
TEST 68.41 FAILED
********************************
TEST 69:
Active player = 0
Deck size =  9
Discard size =  2
Deck treasure count =  1
Discard treasure count =  1
TEST 69.21 FAILED
********************************
TEST 70:
Active player = 3
Deck size =  4
Discard size =  0
Deck treasure count =  1
Discard treasure count =  0
TEST 70.21 FAILED
TEST 70.41 FAILED
********************************
TEST 71:
Active player = 3
Deck size =  5
Discard size =  8
Deck treasure count =  0
Discard treasure count =  0
TEST 71.11 FAILED
********************************
TEST 72:
Active player = 1
Deck size =  6
Discard size =  2
Deck treasure count =  1
Discard treasure count =  0
TEST 72.21 FAILED
TEST 72.41 FAILED
********************************
TEST 73:
Active player = 0
Deck size =  3
Discard size =  10
Deck treasure count =  0
Discard treasure count =  1
TEST 73.21 FAILED
********************************
TEST 74:
Active player = 3
Deck size =  3
Discard size =  7
Deck treasure count =  1
Discard treasure count =  0
TEST 74.21 FAILED
TEST 74.41 FAILED
********************************
TEST 75:
Active player = 0
Deck size =  10
Discard size =  9
Deck treasure count =  2
Discard treasure count =  1
TEST 75.11 FAILED
TEST 75.41 FAILED
********************************
TEST 76:
Active player = 1
Deck size =  4
Discard size =  5
Deck treasure count =  0
Discard treasure count =  2
TEST 76.11 FAILED
TEST 76.21 FAILED
TEST 76.41 FAILED
********************************
TEST 77:
Active player = 2
Deck size =  2
Discard size =  6
Deck treasure count =  1
Discard treasure count =  0
TEST 77.21 FAILED
TEST 77.41 FAILED
********************************
TEST 78:
Active player = 0
Deck size =  0
Discard size =  0
Deck treasure count =  0
Discard treasure count =  0
TEST 78.11 FAILED
TEST 78.41 FAILED
********************************
TEST 79:
Active player = 2
Deck size =  5
Discard size =  6
Deck treasure count =  0
Discard treasure count =  1
TEST 79.21 FAILED
TEST 79.41 FAILED
********************************
TEST 80:
Active player = 1
Deck size =  3
Discard size =  2
Deck treasure count =  1
Discard treasure count =  1
TEST 80.11 FAILED
TEST 80.21 FAILED
TEST 80.41 FAILED
********************************
TEST 81:
Active player = 2
Deck size =  4
Discard size =  5
Deck treasure count =  1
Discard treasure count =  1
TEST 81.11 FAILED
TEST 81.21 FAILED
TEST 81.41 FAILED
********************************
TEST 82:
Active player = 2
Deck size =  7
Discard size =  9
Deck treasure count =  0
Discard treasure count =  2
TEST 82.11 FAILED
TEST 82.21 FAILED
TEST 82.41 FAILED
********************************
TEST 83:
Active player = 2
Deck size =  0
Discard size =  0
Deck treasure count =  0
Discard treasure count =  0
TEST 83.11 FAILED
********************************
TEST 84:
Active player = 2
Deck size =  4
Discard size =  3
Deck treasure count =  1
Discard treasure count =  0
TEST 84.21 FAILED
TEST 84.41 FAILED
********************************
TEST 85:
Active player = 1
Deck size =  6
Discard size =  4
Deck treasure count =  1
Discard treasure count =  0
TEST 85.21 FAILED
TEST 85.41 FAILED
********************************
TEST 86:
Active player = 2
Deck size =  4
Discard size =  8
Deck treasure count =  2
Discard treasure count =  1
TEST 86.11 FAILED
TEST 86.41 FAILED
********************************
TEST 87:
Active player = 0
Deck size =  3
Discard size =  8
Deck treasure count =  1
Discard treasure count =  0
TEST 87.21 FAILED
********************************
TEST 88:
Active player = 0
Deck size =  2
Discard size =  6
Deck treasure count =  1
Discard treasure count =  2
TEST 88.11 FAILED
TEST 88.41 FAILED
********************************
TEST 89:
Active player = 2
Deck size =  4
Discard size =  7
Deck treasure count =  1
Discard treasure count =  1
TEST 89.11 FAILED
TEST 89.21 FAILED
TEST 89.41 FAILED
********************************
TEST 90:
Active player = 0
Deck size =  8
Discard size =  9
Deck treasure count =  1
Discard treasure count =  3
TEST 90.11 FAILED
TEST 90.41 FAILED
********************************
TEST 91:
Active player = 2
Deck size =  6
Discard size =  7
Deck treasure count =  1
Discard treasure count =  1
TEST 91.11 FAILED
TEST 91.21 FAILED
TEST 91.41 FAILED
********************************
TEST 92:
Active player = 1
Deck size =  4
Discard size =  6
Deck treasure count =  0
Discard treasure count =  1
TEST 92.21 FAILED
TEST 92.41 FAILED
********************************
TEST 93:
Active player = 3
Deck size =  5
Discard size =  1
Deck treasure count =  0
Discard treasure count =  0
TEST 93.11 FAILED
********************************
TEST 94:
Active player = 0
Deck size =  6
Discard size =  0
Deck treasure count =  1
Discard treasure count =  0
TEST 94.21 FAILED
********************************
TEST 95:
Active player = 0
Deck size =  10
Discard size =  1
Deck treasure count =  5
Discard treasure count =  0
TEST 95.11 FAILED
TEST 95.41 FAILED
********************************
TEST 96:
Active player = 2
Deck size =  5
Discard size =  3
Deck treasure count =  0
Discard treasure count =  1
TEST 96.21 FAILED
TEST 96.41 FAILED
********************************
TEST 97:
Active player = 1
Deck size =  3
Discard size =  5
Deck treasure count =  0
Discard treasure count =  0
TEST 97.11 FAILED
********************************
TEST 98:
Active player = 2
Deck size =  7
Discard size =  9
Deck treasure count =  0
Discard treasure count =  0
TEST 98.11 FAILED
********************************
TEST 99:
Active player = 2
Deck size =  0
Discard size =  9
Deck treasure count =  0
Discard treasure count =  2
TEST 99.11 FAILED
TEST 99.21 FAILED
TEST 99.41 FAILED
********************************
TEST 100:
Active player = 0
Deck size =  8
Discard size =  5
Deck treasure count =  1
Discard treasure count =  2
TEST 100.11 FAILED
TEST 100.41 FAILED

gcov results for dominion.c:
Function 'compare'
Lines executed:100.00% of 6
Branches executed:100.00% of 4
Taken at least once:100.00% of 4
No calls

Function 'newGame'
Lines executed:0.00% of 2
No branches
No calls

Function 'kingdomCards'
Lines executed:0.00% of 12
No branches
No calls

Function 'initializeGame'
Lines executed:12.82% of 78
Branches executed:26.09% of 46
Taken at least once:17.39% of 46
No calls

Function 'shuffle'
Lines executed:100.00% of 18
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
No calls

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
No calls

Function 'buyCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
No calls

Function 'numHandCards'
Lines executed:0.00% of 1
No branches
No calls

Function 'handCard'
Lines executed:0.00% of 2
No branches
No calls

Function 'supplyCount'
Lines executed:0.00% of 1
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 11
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'whoseTurn'
Lines executed:100.00% of 1
No branches
No calls

Function 'endTurn'
Lines executed:0.00% of 22
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
No calls

Function 'isGameOver'
Lines executed:0.00% of 12
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'scoreFor'
Lines executed:0.00% of 26
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
No calls

Function 'getWinners'
Lines executed:0.00% of 33
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
No calls

Function 'drawCard'
Lines executed:100.00% of 24
Branches executed:100.00% of 6
Taken at least once:100.00% of 6
No calls

Function 'getCost'
Lines executed:0.00% of 30
Branches executed:0.00% of 28
Taken at least once:0.00% of 28
No calls

Function 'cardEffect'
Lines executed:0.00% of 258
Branches executed:0.00% of 179
Taken at least once:0.00% of 179
No calls

Function 'discardCard'
Lines executed:73.33% of 15
Branches executed:100.00% of 6
Taken at least once:50.00% of 6
No calls

Function 'gainCard'
Lines executed:0.00% of 15
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
No calls

Function 'updateCoins'
Lines executed:0.00% of 14
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'playAdventurer'
Lines executed:100.00% of 21
Branches executed:100.00% of 14
Taken at least once:100.00% of 14
No calls

Function 'playSmithy'
Lines executed:0.00% of 6
Branches executed:0.00% of 2
Taken at least once:0.00% of 2
No calls

Function 'playVillage'
Lines executed:0.00% of 5
No branches
No calls

Function 'playGreatHall'
Lines executed:0.00% of 6
No branches
No calls

Function 'playCouncilRoom'
Lines executed:0.00% of 10
Branches executed:0.00% of 4
Taken at least once:0.00% of 4
No calls

File 'dominion.c'
Lines executed:13.87% of 656
Branches executed:11.99% of 417
Taken at least once:10.31% of 417
No calls
dominion.c:creating 'dominion.c.gcov'


dominion.c.gcov:
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <math.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "dominion.h"
        -:    5:#include "dominion_helpers.h"
        -:    6:#include "rngs.h"
        -:    7:
function compare called 874 returned 100% blocks executed 100%
        -:    8:int compare(const void* a, const void* b) {
      874:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 53%
branch  1 taken 47%
      465:   10:    return 1;
      409:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 76%
branch  1 taken 24%
      312:   12:    return -1;
       97:   13:  return 0;
      874:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
        -:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 1 returned 100% blocks executed 17%
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        1:   44:  SelectStream(1);
        1:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
        2:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        1:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
        2:   57:  for (i = 0; i < 10; i++)
branch  0 taken 100%
branch  1 taken 0%
        -:   58:    {
        6:   59:      for (j = 0; j < 10; j++)
branch  0 taken 100%
branch  1 taken 0%
        -:   60:        {
        5:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 67%
branch  1 taken 33%
branch  2 taken 50%
branch  3 taken 50%
        -:   62:	    {
        1:   63:	      return -1;
        -:   64:	    }
        2:   65:        }
    #####:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
    #####:   73:  if (numPlayers == 2)
branch  0 never executed
branch  1 never executed
        -:   74:    {
    #####:   75:      state->supplyCount[curse] = 10;
    #####:   76:    }
    #####:   77:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
    #####:   87:  if (numPlayers == 2)
branch  0 never executed
branch  1 never executed
        -:   88:    {
    #####:   89:      state->supplyCount[estate] = 8;
    #####:   90:      state->supplyCount[duchy] = 8;
    #####:   91:      state->supplyCount[province] = 8;
    #####:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
    #####:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  102:  state->supplyCount[silver] = 40;
    #####:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    #####:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 never executed
branch  1 never executed
        -:  107:    {
    #####:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 never executed
branch  1 never executed
        -:  109:	{
    #####:  110:	  if (kingdomCards[j] == i)
branch  0 never executed
branch  1 never executed
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
    #####:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  114:		{
    #####:  115:		  if (numPlayers == 2){ 
branch  0 never executed
branch  1 never executed
    #####:  116:		    state->supplyCount[i] = 8; 
    #####:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
    #####:  119:		}
        -:  120:	      else
        -:  121:		{
    #####:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
    #####:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    #####:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
    #####:  130:	}
        -:  131:
    #####:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
    #####:  138:  for (i = 0; i < numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  139:    {
    #####:  140:      state->deckCount[i] = 0;
    #####:  141:      for (j = 0; j < 3; j++)
branch  0 never executed
branch  1 never executed
        -:  142:	{
    #####:  143:	  state->deck[i][j] = estate;
    #####:  144:	  state->deckCount[i]++;
    #####:  145:	}
    #####:  146:      for (j = 3; j < 10; j++)
branch  0 never executed
branch  1 never executed
        -:  147:	{
    #####:  148:	  state->deck[i][j] = copper;
    #####:  149:	  state->deckCount[i]++;		
    #####:  150:	}
    #####:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
    #####:  154:  for (i = 0; i < numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  155:    {
    #####:  156:      if ( shuffle(i, state) < 0 )
branch  0 never executed
branch  1 never executed
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
    #####:  160:    }
        -:  161:
        -:  162:  //draw player hands
    #####:  163:  for (i = 0; i < numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  164:    {  
        -:  165:      //initialize hand size to zero
    #####:  166:      state->handCount[i] = 0;
    #####:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
    #####:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    #####:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 never executed
branch  1 never executed
        -:  177:    {
    #####:  178:      state->embargoTokens[i] = 0;
    #####:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
    #####:  182:  state->outpostPlayed = 0;
    #####:  183:  state->phase = 0;
    #####:  184:  state->numActions = 1;
    #####:  185:  state->numBuys = 1;
    #####:  186:  state->playedCardCount = 0;
    #####:  187:  state->whoseTurn = 0;
    #####:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
    #####:  192:  for (it = 0; it < 5; it++){
branch  0 never executed
branch  1 never executed
    #####:  193:    drawCard(state->whoseTurn, state);
    #####:  194:  }
        -:  195:
    #####:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
    #####:  198:  return 0;
        1:  199:}
        -:  200:
function shuffle called 3864 returned 100% blocks executed 100%
        -:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     3864:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     3864:  209:  if (state->deckCount[player] < 1)
branch  0 taken 98%
branch  1 taken 2%
     3785:  210:    return -1;
       79:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1058:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 85%
branch  1 taken 15%
      450:  215:    card = floor(Random() * state->deckCount[player]);
      450:  216:    newDeck[newDeckPos] = state->deck[player][card];
      450:  217:    newDeckPos++;
     2270:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 60%
branch  1 taken 40%
      685:  219:      state->deck[player][i] = state->deck[player][i+1];
      685:  220:    }
      450:  221:    state->deckCount[player]--;
        -:  222:  }
     1058:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 85%
branch  1 taken 15%
      450:  224:    state->deck[player][i] = newDeck[i];
      450:  225:    state->deckCount[player]++;
      450:  226:  }
        -:  227:
       79:  228:  return 0;
     3864:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
        -:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:  
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
branch  0 never executed
branch  1 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:	
    #####:  269:  return 0;
    #####:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
        -:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
branch  0 never executed
branch  1 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
branch  0 never executed
branch  1 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
    #####:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
        -:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
        -:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
        -:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
        -:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
    #####:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
    #####:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
    #####:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 100 returned 100% blocks executed 100%
        -:  346:int whoseTurn(struct gameState *state) {
      100:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
        -:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
    #####:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
        -:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
    #####:  407:	}
    #####:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
    #####:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
        -:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
    #####:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
    #####:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
    #####:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
        -:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
    #####:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
        -:  474:	}
    #####:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
    #####:  484:	}
    #####:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
    #####:  495:	}
    #####:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
    #####:  505:	}
    #####:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
    #####:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
    #####:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 2765 returned 100% blocks executed 100%
        -:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     2765:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 70%
branch  1 taken 30%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
     4764:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 19%
branch  1 taken 81%
      450:  534:      state->deck[player][i] = state->discard[player][i];
      450:  535:      state->discard[player][i] = -1;
      450:  536:    }
        -:  537:
     1932:  538:    state->deckCount[player] = state->discardCount[player];
     1932:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
     1932:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
     1932:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
     1932:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
     1932:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
     1932:  559:    if (deckCounter == 0)
branch  0 taken 96%
branch  1 taken 4%
     1853:  560:      return -1;
        -:  561:
       79:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       79:  563:    state->deckCount[player]--;
       79:  564:    state->handCount[player]++;//Increment hand count
       79:  565:  }
        -:  566:
        -:  567:  else{
      833:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
      833:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
      833:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      833:  576:    state->deckCount[player]--;
      833:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
      912:  580:  return 0;
     2765:  581:}
        -:  582:
function getCost called 0 returned 0% blocks executed 0%
        -:  583:int getCost(int cardNumber)
        -:  584:{
    #####:  585:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
    #####:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
    #####:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
    #####:  644:}
        -:  645:
function cardEffect called 0 returned 0% blocks executed 0%
        -:  646:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  647:{
        -:  648:  int i;
        -:  649:  int j;
        -:  650:  int k; 
        -:  651:  int x;
        -:  652:  int index;
    #####:  653:  int currentPlayer = whoseTurn(state);
    #####:  654:  int nextPlayer = currentPlayer + 1;
        -:  655:
    #####:  656:  int tributeRevealedCards[2] = {-1, -1};
        -:  657:  int temphand[MAX_HAND];// moved above the if statement
    #####:  658:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  659:    nextPlayer = 0;
    #####:  660:  }
        -:  661:  
        -:  662:	
        -:  663:  //uses switch to select card and perform actions
    #####:  664:  switch( card ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  665:    {
        -:  666:    case adventurer:
    #####:  667:      playAdventurer(state,handPos);
    #####:  668:      return 0;
        -:  669:    case council_room:
    #####:  670:      playCouncilRoom(state,handPos);
    #####:  671:      return 0;
        -:  672:    case feast:
        -:  673:      //gain card with cost up to 5
        -:  674:      //Backup hand
    #####:  675:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  676:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  677:	state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  678:      }
        -:  679:      //Backup hand
        -:  680:
        -:  681:      //Update Coins for Buy
    #####:  682:      updateCoins(currentPlayer, state, 5);
    #####:  683:      x = 1;//Condition to loop on
    #####:  684:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  685:	if (supplyCount(choice1, state) <= 0){
branch  0 never executed
branch  1 never executed
        -:  686:	  if (DEBUG)
        -:  687:	    printf("None of that card left, sorry!\n");
        -:  688:
        -:  689:	  if (DEBUG){
        -:  690:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  691:	  }
    #####:  692:	}
    #####:  693:	else if (state->coins < getCost(choice1)){
branch  0 never executed
branch  1 never executed
    #####:  694:	  printf("That card is too expensive!\n");
        -:  695:
        -:  696:	  if (DEBUG){
        -:  697:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  698:	  }
    #####:  699:	}
        -:  700:	else{
        -:  701:
        -:  702:	  if (DEBUG){
        -:  703:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  704:	  }
        -:  705:
    #####:  706:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  707:	  x = 0;//No more buying cards
        -:  708:
        -:  709:	  if (DEBUG){
        -:  710:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  711:	  }
        -:  712:
        -:  713:	}
        -:  714:      }     
        -:  715:
        -:  716:      //Reset Hand
    #####:  717:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  718:	state->hand[currentPlayer][i] = temphand[i];
    #####:  719:	temphand[i] = -1;
    #####:  720:      }
        -:  721:      //Reset Hand
        -:  722:      			
    #####:  723:      return 0;
        -:  724:			
        -:  725:    case gardens:
    #####:  726:      return -1;
        -:  727:			
        -:  728:    case mine:
    #####:  729:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  730:
    #####:  731:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  732:	{
    #####:  733:	  return -1;
        -:  734:	}
        -:  735:		
    #####:  736:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  737:	{
    #####:  738:	  return -1;
        -:  739:	}
        -:  740:
    #####:  741:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
branch  0 never executed
branch  1 never executed
        -:  742:	{
    #####:  743:	  return -1;
        -:  744:	}
        -:  745:
    #####:  746:      gainCard(choice2, state, 2, currentPlayer);
        -:  747:
        -:  748:      //discard card from hand
    #####:  749:      discardCard(handPos, currentPlayer, state, 0);
        -:  750:
        -:  751:      //discard trashed card
    #####:  752:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  753:	{
    #####:  754:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  755:	    {
    #####:  756:	      discardCard(i, currentPlayer, state, 0);			
    #####:  757:	      break;
        -:  758:	    }
    #####:  759:	}
        -:  760:			
    #####:  761:      return 0;
        -:  762:			
        -:  763:    case remodel:
    #####:  764:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
    #####:  766:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
branch  0 never executed
branch  1 never executed
        -:  767:	{
    #####:  768:	  return -1;
        -:  769:	}
        -:  770:
    #####:  771:      gainCard(choice2, state, 0, currentPlayer);
        -:  772:
        -:  773:      //discard card from hand
    #####:  774:      discardCard(handPos, currentPlayer, state, 0);
        -:  775:
        -:  776:      //discard trashed card
    #####:  777:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  778:	{
    #####:  779:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  780:	    {
    #####:  781:	      discardCard(i, currentPlayer, state, 0);			
    #####:  782:	      break;
        -:  783:	    }
    #####:  784:	}
        -:  785:
        -:  786:
    #####:  787:      return 0;
        -:  788:		
        -:  789:    case smithy:
    #####:  790:      playSmithy(state,handPos);
    #####:  791:      return 0;
        -:  792:    case village:
    #####:  793:      playVillage(state,handPos);
    #####:  794:      return 0;
        -:  795:    case baron:
    #####:  796:      state->numBuys++;//Increase buys by 1!
    #####:  797:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  798:	int p = 0;//Iterator for hand!
    #####:  799:	int card_not_discarded = 1;//Flag for discard set!
    #####:  800:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  801:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  802:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  803:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  804:	    state->discardCount[currentPlayer]++;
    #####:  805:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  806:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  807:	    }
    #####:  808:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  809:	    state->handCount[currentPlayer]--;
    #####:  810:	    card_not_discarded = 0;//Exit the loop
    #####:  811:	  }
    #####:  812:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  813:	    if(DEBUG) {
        -:  814:	      printf("No estate cards in your hand, invalid choice\n");
        -:  815:	      printf("Must gain an estate if there are any\n");
        -:  816:	    }
    #####:  817:	    if (supplyCount(estate, state) > 0){
branch  0 never executed
branch  1 never executed
    #####:  818:	      gainCard(estate, state, 0, currentPlayer);
    #####:  819:	      state->supplyCount[estate]--;//Decrement estates
    #####:  820:	      if (supplyCount(estate, state) == 0){
branch  0 never executed
branch  1 never executed
    #####:  821:		isGameOver(state);
    #####:  822:	      }
    #####:  823:	    }
    #####:  824:	    card_not_discarded = 0;//Exit the loop
    #####:  825:	  }
        -:  826:			    
        -:  827:	  else{
    #####:  828:	    p++;//Next card
        -:  829:	  }
        -:  830:	}
    #####:  831:      }
        -:  832:			    
        -:  833:      else{
    #####:  834:	if (supplyCount(estate, state) > 0){
branch  0 never executed
branch  1 never executed
    #####:  835:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  836:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  837:	  if (supplyCount(estate, state) == 0){
branch  0 never executed
branch  1 never executed
    #####:  838:	    isGameOver(state);
    #####:  839:	  }
    #####:  840:	}
        -:  841:      }
        -:  842:	    
        -:  843:      
    #####:  844:      return 0;
        -:  845:		
        -:  846:    case great_hall:
    #####:  847:      playGreatHall(state,handPos);
    #####:  848:      return 0;
        -:  849:    case minion:
        -:  850:      //+1 action
    #####:  851:      state->numActions++;
        -:  852:			
        -:  853:      //discard card from hand
    #####:  854:      discardCard(handPos, currentPlayer, state, 0);
        -:  855:			
    #####:  856:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  857:	{
    #####:  858:	  state->coins = state->coins + 2;
    #####:  859:	}
        -:  860:			
    #####:  861:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  862:	{
        -:  863:	  //discard hand
    #####:  864:	  while(numHandCards(state) > 0)
branch  0 never executed
branch  1 never executed
        -:  865:	    {
    #####:  866:	      discardCard(handPos, currentPlayer, state, 0);
        -:  867:	    }
        -:  868:				
        -:  869:	  //draw 4
    #####:  870:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  871:	    {
    #####:  872:	      drawCard(currentPlayer, state);
    #####:  873:	    }
        -:  874:				
        -:  875:	  //other players discard hand and redraw if hand size > 4
    #####:  876:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  877:	    {
    #####:  878:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  879:		{
    #####:  880:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  881:		    {
        -:  882:		      //discard hand
    #####:  883:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -:  884:			{
    #####:  885:			  discardCard(handPos, i, state, 0);
        -:  886:			}
        -:  887:							
        -:  888:		      //draw 4
    #####:  889:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -:  890:			{
    #####:  891:			  drawCard(i, state);
    #####:  892:			}
    #####:  893:		    }
    #####:  894:		}
    #####:  895:	    }
        -:  896:				
    #####:  897:	}
    #####:  898:      return 0;
        -:  899:		
        -:  900:    case steward:
    #####:  901:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  902:	{
        -:  903:	  //+2 cards
    #####:  904:	  drawCard(currentPlayer, state);
    #####:  905:	  drawCard(currentPlayer, state);
    #####:  906:	}
    #####:  907:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  908:	{
        -:  909:	  //+2 coins
    #####:  910:	  state->coins = state->coins + 2;
    #####:  911:	}
        -:  912:      else
        -:  913:	{
        -:  914:	  //trash 2 cards in hand
    #####:  915:	  discardCard(choice2, currentPlayer, state, 1);
    #####:  916:	  discardCard(choice3, currentPlayer, state, 1);
        -:  917:	}
        -:  918:			
        -:  919:      //discard card from hand
    #####:  920:      discardCard(handPos, currentPlayer, state, 0);
    #####:  921:      return 0;
        -:  922:		
        -:  923:    case tribute:
    #####:  924:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####:  925:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####:  926:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  927:	  state->deckCount[nextPlayer]--;
    #####:  928:	}
    #####:  929:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####:  930:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  931:	  state->discardCount[nextPlayer]--;
    #####:  932:	}
        -:  933:	else{
        -:  934:	  //No Card to Reveal
        -:  935:	  if (DEBUG){
        -:  936:	    printf("No cards to reveal\n");
        -:  937:	  }
        -:  938:	}
    #####:  939:      }
        -:  940:	    
        -:  941:      else{
    #####:  942:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####:  943:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  944:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  945:	    state->deckCount[nextPlayer]++;
    #####:  946:	    state->discard[nextPlayer][i] = -1;
    #####:  947:	    state->discardCount[nextPlayer]--;
    #####:  948:	  }
        -:  949:			    
    #####:  950:	  shuffle(nextPlayer,state);//Shuffle the deck
    #####:  951:	} 
    #####:  952:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  953:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  954:	state->deckCount[nextPlayer]--;
    #####:  955:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  956:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  957:	state->deckCount[nextPlayer]--;
        -:  958:      }    
        -:  959:		       
    #####:  960:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####:  961:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  962:	state->playedCardCount++;
    #####:  963:	tributeRevealedCards[1] = -1;
    #####:  964:      }
        -:  965:
    #####:  966:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####:  967:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  968:	  state->coins += 2;
    #####:  969:	}
        -:  970:		    
    #####:  971:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  972:	  drawCard(currentPlayer, state);
    #####:  973:	  drawCard(currentPlayer, state);
    #####:  974:	}
        -:  975:	else{//Action Card
    #####:  976:	  state->numActions = state->numActions + 2;
        -:  977:	}
    #####:  978:      }
        -:  979:	    
    #####:  980:      return 0;
        -:  981:		
        -:  982:    case ambassador:
    #####:  983:      j = 0;		//used to check if player has enough cards to discard
        -:  984:
    #####:  985:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  986:	{
    #####:  987:	  return -1;				
        -:  988:	}
        -:  989:
    #####:  990:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -:  991:	{
    #####:  992:	  return -1;
        -:  993:	}
        -:  994:
    #####:  995:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  996:	{
    #####:  997:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  998:	    {
    #####:  999:	      j++;
    #####: 1000:	    }
    #####: 1001:	}
    #####: 1002:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1003:	{
    #####: 1004:	  return -1;				
        -: 1005:	}
        -: 1006:
        -: 1007:      if (DEBUG) 
        -: 1008:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1009:
        -: 1010:      //increase supply count for choosen card by amount being discarded
    #####: 1011:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1012:			
        -: 1013:      //each other player gains a copy of revealed card
    #####: 1014:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1015:	{
    #####: 1016:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1017:	    {
    #####: 1018:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1019:	    }
    #####: 1020:	}
        -: 1021:
        -: 1022:      //discard played card from hand
    #####: 1023:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1024:
        -: 1025:      //trash copies of cards returned to supply
    #####: 1026:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1027:	{
    #####: 1028:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1029:	    {
    #####: 1030:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1031:		{
    #####: 1032:		  discardCard(i, currentPlayer, state, 1);
    #####: 1033:		  break;
        -: 1034:		}
    #####: 1035:	    }
    #####: 1036:	}			
        -: 1037:
    #####: 1038:      return 0;
        -: 1039:		
        -: 1040:    case cutpurse:
        -: 1041:
    #####: 1042:      updateCoins(currentPlayer, state, 2);
    #####: 1043:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1044:	{
    #####: 1045:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1046:	    {
    #####: 1047:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1048:		{
    #####: 1049:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1050:		    {
    #####: 1051:		      discardCard(j, i, state, 0);
    #####: 1052:		      break;
        -: 1053:		    }
    #####: 1054:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1055:		    {
    #####: 1056:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1057:			{
        -: 1058:			  if (DEBUG)
        -: 1059:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1060:			}	
    #####: 1061:		      break;
        -: 1062:		    }		
    #####: 1063:		}
        -: 1064:					
    #####: 1065:	    }
        -: 1066:				
    #####: 1067:	}				
        -: 1068:
        -: 1069:      //discard played card from hand
    #####: 1070:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1071:
    #####: 1072:      return 0;
        -: 1073:
        -: 1074:		
        -: 1075:    case embargo: 
        -: 1076:      //+2 Coins
    #####: 1077:      state->coins = state->coins + 2;
        -: 1078:			
        -: 1079:      //see if selected pile is in play
    #####: 1080:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1081:	{
    #####: 1082:	  return -1;
        -: 1083:	}
        -: 1084:			
        -: 1085:      //add embargo token to selected supply pile
    #####: 1086:      state->embargoTokens[choice1]++;
        -: 1087:			
        -: 1088:      //trash card
    #####: 1089:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1090:      return 0;
        -: 1091:		
        -: 1092:    case outpost:
        -: 1093:      //set outpost flag
    #####: 1094:      state->outpostPlayed++;
        -: 1095:			
        -: 1096:      //discard card
    #####: 1097:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1098:      return 0;
        -: 1099:		
        -: 1100:    case salvager:
        -: 1101:      //+1 buy
    #####: 1102:      state->numBuys++;
        -: 1103:			
    #####: 1104:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1105:	{
        -: 1106:	  //gain coins equal to trashed card
    #####: 1107:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1108:	  //trash card
    #####: 1109:	  discardCard(choice1, currentPlayer, state, 1);	
    #####: 1110:	}
        -: 1111:			
        -: 1112:      //discard card
    #####: 1113:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1114:      return 0;
        -: 1115:		
        -: 1116:    case sea_hag:
    #####: 1117:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1118:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1119:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1120:	  state->discardCount[i]++;
    #####: 1121:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1122:	}
    #####: 1123:      }
    #####: 1124:      return 0;
        -: 1125:		
        -: 1126:    case treasure_map:
        -: 1127:      //search hand for another treasure_map
    #####: 1128:      index = -1;
    #####: 1129:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1130:	{
    #####: 1131:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1132:	    {
    #####: 1133:	      index = i;
    #####: 1134:	      break;
        -: 1135:	    }
    #####: 1136:	}
    #####: 1137:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1138:	{
        -: 1139:	  //trash both treasure cards
    #####: 1140:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1141:	  discardCard(index, currentPlayer, state, 1);
        -: 1142:
        -: 1143:	  //gain 4 Gold cards
    #####: 1144:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1145:	    {
    #####: 1146:	      gainCard(gold, state, 1, currentPlayer);
    #####: 1147:	    }
        -: 1148:				
        -: 1149:	  //return success
    #####: 1150:	  return 1;
        -: 1151:	}
        -: 1152:			
        -: 1153:      //no second treasure_map found in hand
    #####: 1154:      return -1;
        -: 1155:    }
        -: 1156:	
    #####: 1157:  return -1;
    #####: 1158:}
        -: 1159:
function discardCard called 100 returned 100% blocks executed 80%
        -: 1160:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1161:{
        -: 1162:	
        -: 1163:  //if card is not trashed, added to Played pile 
      100: 1164:  if (trashFlag < 1)
branch  0 taken 100%
branch  1 taken 0%
        -: 1165:    {
        -: 1166:      //add card to played pile
      100: 1167:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      100: 1168:      state->playedCardCount++;
      100: 1169:    }
        -: 1170:	
        -: 1171:  //set played card to -1
      100: 1172:  state->hand[currentPlayer][handPos] = -1;
        -: 1173:	
        -: 1174:  //remove card from player's hand
      100: 1175:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0%
branch  1 taken 100%
        -: 1176:    {
        -: 1177:      //reduce number of cards in hand
    #####: 1178:      state->handCount[currentPlayer]--;
    #####: 1179:    }
      100: 1180:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0%
branch  1 taken 100%
        -: 1181:    {
        -: 1182:      //reduce number of cards in hand
    #####: 1183:      state->handCount[currentPlayer]--;
    #####: 1184:    }
        -: 1185:  else 	
        -: 1186:    {
        -: 1187:      //replace discarded card with last card in hand
      100: 1188:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1189:      //set last card to -1
      100: 1190:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1191:      //reduce number of cards in hand
      100: 1192:      state->handCount[currentPlayer]--;
        -: 1193:    }
        -: 1194:	
      100: 1195:  return 0;
        -: 1196:}
        -: 1197:
function gainCard called 0 returned 0% blocks executed 0%
        -: 1198:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1199:{
        -: 1200:  //Note: supplyPos is enum of choosen card
        -: 1201:	
        -: 1202:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1203:  if ( supplyCount(supplyPos, state) < 1 )
branch  0 never executed
branch  1 never executed
        -: 1204:    {
    #####: 1205:      return -1;
        -: 1206:    }
        -: 1207:	
        -: 1208:  //added card for [whoseTurn] current player:
        -: 1209:  // toFlag = 0 : add to discard
        -: 1210:  // toFlag = 1 : add to deck
        -: 1211:  // toFlag = 2 : add to hand
        -: 1212:
    #####: 1213:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1214:    {
    #####: 1215:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1216:      state->deckCount[player]++;
    #####: 1217:    }
    #####: 1218:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1219:    {
    #####: 1220:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1221:      state->handCount[player]++;
    #####: 1222:    }
        -: 1223:  else
        -: 1224:    {
    #####: 1225:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1226:      state->discardCount[player]++;
        -: 1227:    }
        -: 1228:	
        -: 1229:  //decrease number in supply pile
    #####: 1230:  state->supplyCount[supplyPos]--;
        -: 1231:	 
    #####: 1232:  return 0;
    #####: 1233:}
        -: 1234:
function updateCoins called 0 returned 0% blocks executed 0%
        -: 1235:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1236:{
        -: 1237:  int i;
        -: 1238:	
        -: 1239:  //reset coin count
    #####: 1240:  state->coins = 0;
        -: 1241:
        -: 1242:  //add coins for each Treasure card in player's hand
    #####: 1243:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -: 1244:    {
    #####: 1245:      if (state->hand[player][i] == copper)
branch  0 never executed
branch  1 never executed
        -: 1246:	{
    #####: 1247:	  state->coins += 1;
    #####: 1248:	}
    #####: 1249:      else if (state->hand[player][i] == silver)
branch  0 never executed
branch  1 never executed
        -: 1250:	{
    #####: 1251:	  state->coins += 2;
    #####: 1252:	}
    #####: 1253:      else if (state->hand[player][i] == gold)
branch  0 never executed
branch  1 never executed
        -: 1254:	{
    #####: 1255:	  state->coins += 3;
    #####: 1256:	}	
    #####: 1257:    }	
        -: 1258:
        -: 1259:  //add bonus
    #####: 1260:  state->coins += bonus;
        -: 1261:
    #####: 1262:  return 0;
        -: 1263:}
        -: 1264:
function playAdventurer called 100 returned 100% blocks executed 100%
        -: 1265:int playAdventurer(struct gameState *state,int handPos) {
      100: 1266:      int drawntreasure = 0;
      100: 1267:      int currentPlayer = whoseTurn(state);
        -: 1268:      int temphand[MAX_HAND];
        -: 1269:      int cardDrawn;
      100: 1270:      int z = 0; //counter for tempHand
      100: 1271:      int counter = 0;
        -: 1272:      
    11378: 1273:      while((drawntreasure<3) && (counter < 100)){
branch  0 taken 97%
branch  1 taken 3%
branch  2 taken 97%
branch  3 taken 3%
     2765: 1274:        counter++;
     2765: 1275:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 70%
branch  1 taken 30%
     1932: 1276:	  shuffle(currentPlayer, state);
     1932: 1277:	}
     2765: 1278:	drawCard(currentPlayer, state);
     2765: 1279:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
     8027: 1280:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 97%
branch  1 taken 3%
branch  2 taken 97%
branch  3 taken 3%
branch  4 taken 3%
branch  5 taken 97%
      246: 1281:	  drawntreasure++;
        -: 1282:	else{
     2519: 1283:	  temphand[z]=cardDrawn;
     2519: 1284:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     2519: 1285:	  z++;
        -: 1286:	}
        -: 1287:      }
     5238: 1288:      while(z-1>=0){
branch  0 taken 96%
branch  1 taken 4%
     2519: 1289:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     2519: 1290:	z=z-1;
        -: 1291:      }
        -: 1292:
        -: 1293:      //put played card in played card pile
      100: 1294:      discardCard(handPos, currentPlayer, state, -1);
        -: 1295:      
      100: 1296:      return 0;
        -: 1297:}
        -: 1298:
function playSmithy called 0 returned 0% blocks executed 0%
        -: 1299:int playSmithy(struct gameState *state, int handPos) {
        -: 1300:      int i;
    #####: 1301:      int currentPlayer = whoseTurn(state);
        -: 1302:      //+3 Cards
    #####: 1303:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1304:	{
    #####: 1305:	  drawCard(currentPlayer, state);
    #####: 1306:	}
        -: 1307:			
        -: 1308:      //discard card from hand
    #####: 1309:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1310:      return 0;
        -: 1311:}
        -: 1312:
function playVillage called 0 returned 0% blocks executed 0%
        -: 1313:int playVillage(struct gameState *state, int handPos) {
    #####: 1314:      int currentPlayer = whoseTurn(state);
        -: 1315:      //+1 Card
    #####: 1316:      drawCard(currentPlayer, state);
        -: 1317:			
        -: 1318:      //+2 Actions
    #####: 1319:      state->numActions = state->numActions + 3;
        -: 1320:			
        -: 1321:      //discard played card from hand
    #####: 1322:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1323:      return 0;
        -: 1324:}
        -: 1325:
function playGreatHall called 0 returned 0% blocks executed 0%
        -: 1326:int playGreatHall(struct gameState *state, int handPos) {
    #####: 1327:      int currentPlayer = whoseTurn(state);
        -: 1328:      //+2 Card
    #####: 1329:      drawCard(currentPlayer, state);
    #####: 1330:      drawCard(currentPlayer, state);
        -: 1331:			
        -: 1332:      //+1 Actions
    #####: 1333:      state->numActions++;
        -: 1334:			
        -: 1335:      //discard card from hand
    #####: 1336:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1337:      return 0;
        -: 1338:}
        -: 1339:
function playCouncilRoom called 0 returned 0% blocks executed 0%
        -: 1340:int playCouncilRoom(struct gameState *state, int handPos) {
        -: 1341:      //+4 Cards
        -: 1342:      int i;
    #####: 1343:      int currentPlayer = whoseTurn(state);
    #####: 1344:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1345:	{
    #####: 1346:	  drawCard(currentPlayer, state);
    #####: 1347:	}
        -: 1348:			
        -: 1349:      //+1 Buy
    #####: 1350:      state->numBuys++;
        -: 1351:			
        -: 1352:      //Each other player draws a card
    #####: 1353:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1354:	{
    #####: 1355:	  drawCard(i, state);
    #####: 1356:	}
        -: 1357:			
        -: 1358:      //put played card in played card pile
    #####: 1359:      discardCard(handPos, currentPlayer, state, 0);
        -: 1360:			
    #####: 1361:      return 0;
        -: 1362:}
        -: 1363:
        -: 1364:
        -: 1365://end of dominion.c
        -: 1366:
